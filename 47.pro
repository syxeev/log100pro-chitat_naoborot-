domains
	i = integer
	list = i* 
predicates
	nondeterm mnozh(list, list, list) %Создаёт множество элементов, входящих в список несколько раз
	nondeterm member(i, list) %узнает, принадлежит ли элемент списку
	nondeterm do(char) %Взаимодействие  с меню
	nondeterm run  %Запуск меню
clauses
	member(X, [X|_]). %Если элемент является головой списка, то он принадлежит списку
	member(X, [_|T]):-  %Если первый элемент списка не совпадает с переданным, то поиск элемента продолжается в
		member(X,T).  %хвосте списка, если список опустеет, предикат станет ложным, следовательно элемент не принадлежит списку
	mnozh([H|T], T1, R):-
		member(H,T),    %Если элемент списка H принадлежит его хвосту, и ещё не является элементом списка T1
		not(member(H,T1)), %(элементы, входящие в исходный список несколько раз), то он добавляется в него,
		mnozh(T, [H|T1], R).  %предикат продолжает работу с хвостом списка
	mnozh([H|T], T1, R):-
		member(H, T), %Если элемент списка Н принадлежит его хвосту, и уже является элементом списка Т1,
		member(H, T1), %то он пропускается, предикат продолжает работу с хвостом списка 
		mnozh(T,T1,R).
	mnozh([H|T], T1, R):- 
		not(member(H, T)), %Если элемент списка Н не принадлежит его хвосту, то он пропускается,
		mnozh(T, T1, R). %предикат продолжает работу с хвостом списка
	mnozh([], R, R). %Если исходный список опустел, то получен список всех элементов, входящих в исходный несколько раз(второй список)
			 %он приравнивается к результату (третий список)
	run:-
		write("\n******Enter******\n"),
		write(" 1 to start\n"),
		write(" 0 to EXIT\n"),
		write("*****************\n"),
		write("»"),
		readchar(X),
		write(X),
		nl,
		do(X),
		run.
	do('1'):-
		write("Enter your list\n L = "),
		readterm(list, Z),
		nl,
		mnozh(Z,[],D),
		write(D).
	do('0'):-
		write("That's all."), exit.
	do(_):-
		write("Bad value\n\n").
	goal
	run.
